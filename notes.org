
@title{A tethered system}


In early stages it makes sense to place the burden for editing and
compiling on the host. Having prepared an object file we can send to
the target for execution. Then we can send results back to the host.


In other words, the host has a full operating system. You can
backspace, cut, copy, paste into your terminal window. Once you have
the line the way you want you press enter and the line goes to the
target for processing. The other approach is that when you type a
character in the window it does to the target. Any backspaces, cursor
movements, etc must be processed by the target. This is okay and you
may want to do this, but lets start with the host doing the line
editing.

In fact it is not so easy to find a dumb terminal these days.

It also makes sense to not put strings in the object code. We don't
need the dictionary feature if everything is compiled by the host.

Simple-minded monitor using a polled serial port.

Send a binary file. It is loaded and executed. Repeat.

All exceptions must be handled at least in a trivial way. Say cause a
warm reboot.

@section{Target side}

This is a very simple interpreter based on ideas from "3-instruction
Forth" by Sergeant.

The interpreter reads a byte from the serial device and executes the instruction
represented by that byte.

The three instructions are:

0x01 -- Fetch byte. 
  The target reads the next 4 bytes as an address, gets the byte at
  that address, and transmits it over the serial line.


0x02 -- Store byte.
  The target reads the next 4 bytes as an address, the fifth byte as a
  value and stores the value at the address.

0x03 -- Call. 
  The target reads the next 4 bytes as an address and does a call to
  the subroutine at that address.

When an instruction is finished start waiting for another.


@section{Host side}

The host should have an interactive language. That is one that communicates
via a console of some sort. You type in a command, press enter, and
the command is executed. You could use Lisp, Python, Bash, Forth, and others.

To this language system you add 3 functions: Fetch, Store, Call. You
may also need to jump through some hoops to set up the serial port
communication. 



@section{Load file}
A procedure to copy a binary file onto the target is easy. There is
one "problem". If the binary file is created assuming a particular
load address I have to use that address. Or I have to write the bin
file in a way that doesn't matter. 

So ... rather than "bl mu_rx" maybe "ldr x1, =mu_rx" "br x1"


@section{Examples}
Suppose I want to access the MIDR register. Assembler code is

   mrs x0, MIDR_EL1

to wrap this in a subroutine

get_midr:
   mrs x0, MIDR_EL1
   ret

Currently we don't have a way to access target registers. In general
we will place parameters and return values on a stack. SO maybe add a
routine that gives the current stack ptr.

I might reserve, say, X8 as a parameter stack. 



breakpoint:


dump_registers:
     save them in a scratch area
     return address to host

save_regs
     stp ...
     stp ...
     
